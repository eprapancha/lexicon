{:min-bb-version "1.3.0"
 :tasks
 {:requires ([clojure.string :as str]
             [babashka.fs :as fs]
             [babashka.process :as proc])

  :init
  (do
    (defn run-cmd
      "Run a shell command, printing output and failing on errors"
      [cmd & {:keys [dir] :or {dir "."}}]
      (let [result (proc/shell {:dir dir :out :inherit :err :inherit :continue true}
                               cmd)]
        (when-not (zero? (:exit result))
          (System/exit (:exit result)))))

    (defn print-step [emoji msg]
      (println (str emoji " " msg)))

    (defn check-command [cmd]
      (try
        (let [result (proc/shell {:out :string :err :string :continue true}
                                 (str cmd " --version"))]
          (zero? (:exit result)))
        (catch Exception _ false)))

    (defn ensure-dir [path]
      (fs/create-dirs path))

    (defn setup-cljs-deps! []
      (print-step "ğŸ“¦" "Setting up ClojureScript dependencies...")
      (ensure-dir "packages/editor-cljs/resources/public/js")

      (when (fs/exists? "packages/editor-cljs/node_modules/web-tree-sitter")
        (print-step "ğŸ“" "Copying web-tree-sitter files...")
        (fs/copy "packages/editor-cljs/node_modules/web-tree-sitter/tree-sitter.js"
                "packages/editor-cljs/resources/public/js/web-tree-sitter.js"
                {:replace-existing true})
        (fs/copy "packages/editor-cljs/node_modules/web-tree-sitter/tree-sitter.wasm"
                "packages/editor-cljs/resources/public/js/tree-sitter.wasm"
                {:replace-existing true}))

      (print-step "âœ…" "Dependencies setup complete!"))

    (defn install-cljs! []
      (print-step "ğŸ“¦" "Installing ClojureScript dependencies...")
      (run-cmd "npm install --no-workspaces" :dir "packages/editor-cljs")
      (print-step "âœ…" "ClojureScript dependencies installed!"))

    (defn build-wasm! [mode]
      (print-step "ğŸ¦€" (str "Building Lexicon WASM module (" mode ")..."))
      (when-not (check-command "wasm-pack")
        (print-step "âŒ" "wasm-pack not found. Please install it:")
        (println "   curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh")
        (println "   See: https://rustwasm.github.io/wasm-pack/installer/")
        (System/exit 1))

      (print-step "ğŸ“¦" "Compiling Rust to WebAssembly...")
      (let [flag (if (= mode "release") "--release" "--dev")]
        (run-cmd (str "wasm-pack build --target web --out-dir pkg " flag)
                 :dir "packages/lexicon-engine/wasm"))

      (print-step "ğŸ“" "Copying WASM files to ClojureScript resources...")
      (ensure-dir "packages/editor-cljs/resources/public/lexicon-engine/wasm/pkg")
      (doseq [f (fs/list-dir "packages/lexicon-engine/wasm/pkg")]
        (fs/copy f
                (str "packages/editor-cljs/resources/public/lexicon-engine/wasm/pkg/"
                     (fs/file-name f))
                {:replace-existing true}))

      (print-step "âœ…" "WASM build complete!"))

    (defn build-grammars! []
      (print-step "ğŸŒ³" "Building Tree-sitter grammars...")

      (if-not (or (check-command "tree-sitter") (check-command "tree-sitter-cli"))
        (do
          (print-step "âš ï¸" "tree-sitter CLI not found - skipping grammar builds")
          (println "   Grammars are optional for development")
          (println "   To build grammars, install: npm install -g tree-sitter-cli"))

        (let [grammars-dir "packages/language-grammars"
              grammar-dirs (filter (fn [d]
                                    (and (fs/directory? d)
                                         (fs/exists? (fs/path d "grammar.js"))))
                                  (fs/list-dir grammars-dir))]

          (if (empty? grammar-dirs)
            (print-step "âš ï¸" "No grammars found to build")
            (doseq [grammar-dir grammar-dirs]
              (let [grammar-name (fs/file-name grammar-dir)]
                (print-step "ğŸ“¦" (str "Building grammar: " grammar-name))

                (when (fs/exists? (fs/path grammar-dir "package.json"))
                  (run-cmd "npm install" :dir (str grammar-dir)))

                (try
                  (run-cmd "tree-sitter build-wasm" :dir (str grammar-dir))
                  (catch Exception e
                    (print-step "âš ï¸" (str "Failed to build " grammar-name " - skipping")))))))

          (ensure-dir "packages/editor-cljs/resources/public/grammars")
          (let [wasm-files (fs/glob grammars-dir "**/*.wasm")]
            (if (empty? wasm-files)
              (print-step "âš ï¸" "No grammar WASM files found")
              (doseq [wasm-file wasm-files]
                (fs/copy wasm-file
                        (str "packages/editor-cljs/resources/public/grammars/"
                             (fs/file-name wasm-file))
                        {:replace-existing true}))))

          (print-step "âœ…" "Grammar build complete!"))))

    (defn build-cljs! [mode]
      (let [cmd (if (= mode "release")
                  "npx shadow-cljs release app"
                  "npx shadow-cljs compile app")
            msg (if (= mode "release") "production" "development")]
        (print-step "ğŸ”¨" (str "Building ClojureScript frontend (" msg ")..."))
        (run-cmd cmd :dir "packages/editor-cljs")
        (print-step "âœ…" "ClojureScript build complete!")))

    (defn lint-architecture!
      "Check that packages only import from lexicon.lisp, not core internals."
      []
      (print-step "ğŸ”" "Checking architecture boundary...")
      (let [src-dir "packages/editor-cljs/src/lexicon"
            ;; Find all .cljs files at top level (packages), excluding lisp.cljs
            package-files (->> (fs/list-dir src-dir)
                               (filter (fn [f] (and (fs/regular-file? f)
                                                    (str/ends-with? (str f) ".cljs")
                                                    (not= (fs/file-name f) "lisp.cljs"))))
                               (map str))
            violations (atom 0)
            ;; Regex patterns (can't use literals in EDN)
            core-import-pat (re-pattern "\\[lexicon\\.core\\.")
            reframe-import-pat (re-pattern "\\[re-frame\\.")
            reframe-db-pat (re-pattern "re-frame\\.db")]

        (doseq [file package-files]
          (let [filename (fs/file-name file)
                content (slurp file)]

            ;; Check for imports from lexicon.core.*
            (when (re-find core-import-pat content)
              (print-step "âŒ" (str "VIOLATION: " filename " imports from lexicon.core.*"))
              (println "   Packages must ONLY import from lexicon.lisp")
              (doseq [line (str/split-lines content)]
                (when (re-find core-import-pat line)
                  (println (str "   " (str/trim line)))))
              (swap! violations inc))

            ;; Check for imports from re-frame.*
            (when (re-find reframe-import-pat content)
              (print-step "âŒ" (str "VIOLATION: " filename " imports from re-frame.*"))
              (println "   Packages must ONLY import from lexicon.lisp")
              (doseq [line (str/split-lines content)]
                (when (re-find reframe-import-pat line)
                  (println (str "   " (str/trim line)))))
              (swap! violations inc))

            ;; Check for direct re-frame.db access
            (when (re-find reframe-db-pat content)
              (print-step "âŒ" (str "VIOLATION: " filename " accesses re-frame.db directly"))
              (println "   Packages must ONLY use lexicon.lisp functions")
              (doseq [line (str/split-lines content)]
                (when (re-find reframe-db-pat line)
                  (println (str "   " (str/trim line)))))
              (swap! violations inc))))

        (if (zero? (deref violations))
          (do
            (print-step "âœ…" "Architecture boundary check passed")
            true)
          (do
            (println "")
            (print-step "âŒ" (str "Found " (deref violations) " architecture violation(s)"))
            (println "")
            (println "ARCHITECTURE RULE:")
            (println "  Packages (src/lexicon/*.cljs except lisp.cljs) must ONLY import:")
            (println "    [lexicon.lisp :as lisp]")
            (println "")
            (println "  They must NEVER import from:")
            (println "    - lexicon.core.*")
            (println "    - re-frame.*")
            (println "    - re-frame.db")
            (println "")
            (println "See: docs/ARCHITECTURE_BOUNDARY.md")
            (System/exit 1)))))

    (defn lint-e2e!
      "Check that E2E tests don't use evalLisp for user actions.

       Tests should simulate user interaction via keyboard, not call Lisp directly.
       Allowed: Reading state (get-buffer-text, get-point) for verification.
       Blocked: eval-lisp, evalLisp, setup-eval - these bypass user interaction."
      []
      (print-step "ğŸ”" "Checking E2E tests don't use evalLisp...")
      (let [;; Files that legitimately need eval (testing the eval system itself)
            exempt-files (set ["test_helpers.clj"           ;; Defines the helpers
                               "runtime_eval_test.clj"      ;; Tests eval itself
                               "sci_integration_test.clj"]) ;; Tests SCI integration
            ;; Bad patterns - evalLisp usage in test code
            bad-patterns [[(re-pattern "eval-lisp") "uses eval-lisp (should use keyboard simulation)"]
                         [(re-pattern "evalLisp") "uses evalLisp (should use keyboard simulation)"]
                         [(re-pattern "setup-eval") "uses setup-eval (should use keyboard simulation)"]
                         [(re-pattern "def \\^:dynamic \\*driver\\*") "defines own *driver* (use h/with-driver)"]
                         [(re-pattern "with-driver-and-messages") "uses old fixture (use h/with-driver)"]]
            test-files (fs/glob "e2e_tests" "**/*.clj")
            violations (atom [])]
        (doseq [file test-files]
          (let [filename (str (fs/file-name file))]
            (when-not (contains? exempt-files filename)
              (let [content (slurp (str file))
                    file-violations (atom [])]
                ;; Check each bad pattern
                (doseq [[pat desc] bad-patterns]
                  (when (re-find pat content)
                    (swap! file-violations conj desc)))
                (when (seq (deref file-violations))
                  (swap! violations conj {:file (str file)
                                         :issues (deref file-violations)}))))))
        (if (seq (deref violations))
          (do
            (println "\nERROR: E2E tests should not use evalLisp:\n")
            (doseq [{:keys [file issues]} (sort-by :file (deref violations))]
              (println (str "  " file))
              (doseq [issue issues]
                (println (str "    - " issue))))
            (println "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
            (println "E2E tests should simulate USER ACTIONS via keyboard:")
            (println "")
            (println "  BAD:  (eval-lisp \"(insert \\\"hello\\\")\")")
            (println "  GOOD: (h/type-text \"hello\")")
            (println "")
            (println "  BAD:  (eval-lisp \"(undo)\")")
            (println "  GOOD: (h/press-ctrl \"z\")")
            (println "")
            (println "Reading state for verification is OK:")
            (println "  (is (= \"hello\" (h/get-buffer-text*)))")
            (println "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
            (System/exit 1))
          (print-step "âœ…" "E2E tests don't use evalLisp"))))

    (defn lint-browser-tests!
      "Check that no browser-based tests exist in packages/editor-cljs/test/.
       All E2E tests should be in e2e_tests/ using Etaoin."
      []
      (print-step "ğŸ”" "Checking for browser-based tests...")
      (let [test-dir "packages/editor-cljs/test"
            test-files (->> (fs/glob test-dir "**/*.cljs")
                           (concat (fs/glob test-dir "**/*_test.clj"))
                           (filter (fn [f] (not (str/ends-with? (str f) ".gitkeep"))))
                           (map str)
                           vec)]
        (if (seq test-files)
          (do
            (println "\nERROR: Browser-based tests found in packages/editor-cljs/test/\n")
            (doseq [f test-files]
              (println (str "  " f)))
            (println "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
            (println "DO NOT write tests in packages/editor-cljs/test/")
            (println "")
            (println "All E2E tests should be written in e2e_tests/ using Etaoin.")
            (println "See: e2e_tests/lexicon/keyboard_demo_test.clj for the pattern.")
            (println "")
            (println "Browser-based tests are:")
            (println "  - Hard to debug (no REPL, limited stack traces)")
            (println "  - Flaky (timing issues)")
            (println "  - Slow to run")
            (println "")
            (println "Etaoin tests are:")
            (println "  - Real browser simulation (Firefox/Chrome)")
            (println "  - Debuggable with full Clojure tooling")
            (println "  - Reliable and reproducible")
            (println "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
            (System/exit 1))
          (print-step "âœ…" "No browser-based tests found"))))

    (defn lint-kondo!
      "Run clj-kondo static analysis on ClojureScript code.
       Currently warn-only (doesn't fail build) - fix issues incrementally.
       Skips gracefully if clj-kondo is not installed."
      []
      (if-not (check-command "clj-kondo")
        (do
          (print-step "âš ï¸" "clj-kondo not installed - skipping static analysis")
          true)
        (do
          (print-step "ğŸ”" "Running clj-kondo static analysis...")
          (let [result (proc/shell {:dir "."
                                    :out :string
                                    :err :string
                                    :continue true}
                                   "clj-kondo --lint packages/editor-cljs/src --config .clj-kondo/config.edn")]
            (println (:out result))
            (when-not (empty? (:err result))
              (println (:err result)))
            (if (zero? (:exit result))
              (do
                (print-step "âœ…" "clj-kondo check passed")
                true)
              (do
                ;; Warn only for now - too many false positives from re-frame patterns
                (print-step "âš ï¸" "clj-kondo found issues (warn-only, not blocking)")
                true)))))))

  ;; Linting tasks
  lint:arch
  {:doc "Check architecture boundary (packages must only use lexicon.lisp API)"
   :task (lint-architecture!)}

  lint:kondo
  {:doc "Run clj-kondo static analysis"
   :task (lint-kondo!)}

  lint:e2e
  {:doc "Check E2E tests don't use evalLisp (should simulate user interaction)"
   :task (lint-e2e!)}

  lint:browser-tests
  {:doc "Check no browser-based tests in packages/editor-cljs/test/"
   :task (lint-browser-tests!)}

  lint
  {:doc "Run all linters (architecture + clj-kondo + e2e + browser-tests)"
   :task (do
           (lint-architecture!)
           (lint-kondo!)
           (lint-e2e!)
           (lint-browser-tests!))}

  ;; Individual build tasks
  build-wasm
  {:doc "Build the Rust WASM module (release)"
   :task (build-wasm! "release")}

  build-wasm-debug
  {:doc "Build the Rust WASM module (debug)"
   :task (build-wasm! "debug")}

  build-grammars
  {:doc "Build all Tree-sitter grammars to WebAssembly"
   :task (build-grammars!)}

  setup-cljs-deps
  {:doc "Setup ClojureScript dependencies (copy static assets)"
   :task (setup-cljs-deps!)}

  install-cljs
  {:doc "Install ClojureScript npm dependencies"
   :task (install-cljs!)}

  build-cljs
  {:doc "Build ClojureScript frontend (production)"
   :task (build-cljs! "release")}

  build-cljs-dev
  {:doc "Build ClojureScript frontend (development)"
   :task (build-cljs! "dev")}

  ;; Composite tasks
  build
  {:doc "Build the entire project (WASM + ClojureScript)"
   :task
   (do
     (install-cljs!)
     (setup-cljs-deps!)
     (build-wasm! "release")
     (build-cljs! "release")
     (print-step "ğŸ‰" "Full build completed successfully!"))}

  build-dev
  {:doc "Build the entire project in development mode"
   :task
   (do
     (install-cljs!)
     (setup-cljs-deps!)
     (build-wasm! "debug")
     (build-cljs! "dev")
     (print-step "ğŸ‰" "Development build completed successfully!"))}

  dev
  {:doc "Start the development environment"
   :task
   (do
     (print-step "ğŸš€" "Starting Lexicon development environment...")
     (install-cljs!)
     (setup-cljs-deps!)
     (print-step "ğŸ”„" "Starting ClojureScript watch mode...")
     (println "Frontend: http://localhost:8080")
     (println "")
     (println "Press Ctrl+C to stop")
     (run-cmd "npx shadow-cljs watch app" :dir "packages/editor-cljs"))}

  dev-server
  {:doc "Start the development server"
   :task
   (do
     (print-step "ğŸŒ" "Starting development server...")
     (run-cmd "node dev-server.js" :dir "packages/editor-cljs"))}

  test:unit
  {:doc "Run ClojureScript unit tests"
   :task
   (do
     (print-step "ğŸ§ª" "Running ClojureScript unit tests...")
     (when (fs/exists? "packages/editor-cljs/shadow-cljs.edn")
       (run-cmd "npx shadow-cljs compile test" :dir "packages/editor-cljs"))
     (print-step "âœ…" "Unit tests completed!"))}

  test:unit:watch
  {:doc "Watch ClojureScript unit tests (continuous feedback)"
   :task
   (do
     (print-step "ğŸ‘€" "Watching ClojureScript unit tests...")
     (println "Tests will auto-run on file changes")
     (println "Open http://localhost:8021 in browser to see results")
     (println "Press Ctrl+C to stop")
     (run-cmd "npx shadow-cljs watch test" :dir "packages/editor-cljs"))}

  test:e2e
  {:doc "Run E2E tests with Etaoin (requires Firefox/Chrome WebDriver)
         Usage: bb test:e2e [namespace-pattern]
         Examples:
           bb test:e2e                              # Run all E2E tests
           bb test:e2e prefix-argument-test         # Run only prefix-argument tests
           bb test:e2e basic-editing-test           # Run only basic-editing tests"
   :task
   (do
     (let [test-pattern (first *command-line-args*)
           config-file (if test-pattern
                        (let [config-path (str "/tmp/test-" test-pattern ".edn")
                              ns-regex (str "^lexicon." test-pattern "$")]
                          (spit config-path
                                (str "{:kaocha/reporter [kaocha.report/documentation\n"
                                     "                   kaocha.report.progress/report]\n"
                                     " :kaocha/color? true\n"
                                     " :kaocha/fail-fast? false\n"
                                     " :kaocha/plugins [:kaocha.plugin/junit-xml]\n"
                                     " :kaocha.plugin.junit-xml/target-file \"test-results/junit-" test-pattern ".xml\"\n"
                                     " :kaocha/tests\n"
                                     " [{:kaocha.testable/type :kaocha.type/clojure.test\n"
                                     "   :kaocha.testable/id :e2e\n"
                                     "   :kaocha/source-paths []\n"
                                     "   :kaocha/test-paths [\"e2e_tests\"]\n"
                                     "   :kaocha/ns-patterns [\"" ns-regex "\"]\n"
                                     "   :kaocha.filter/skip-meta [:skip]}]}"))
                          (print-step "ğŸ¯" (str "Running E2E tests matching: " ns-regex))
                          config-path)
                        "tests.edn")]
       (print-step "ğŸŒ" "Running E2E tests with Etaoin...")
       (println "")
       (print-step "ğŸ“‹" "Prerequisites:")
       (println "   1. Firefox installed (or Chrome with geckodriver/chromedriver)")
       (println "   2. App running at http://localhost:8080 (run 'bb dev' in another terminal)")
       (println "")

       (when-not (check-command "firefox")
         (print-step "âš ï¸" "Firefox not found - tests may fail")
         (println "   Install Firefox or update test to use Chrome"))

       (print-step "ğŸ§ª" "Running E2E tests...")
       (run-cmd (str "clojure -M:e2e -m kaocha.runner --config-file " config-file))
       (print-step "âœ…" "E2E tests completed!")))}

  test
  {:doc "Run all tests (unit + E2E + Rust)"
   :task
   (do
     (print-step "ğŸ§ª" "Running all tests...")
     (println "")

     (print-step "ğŸ“" "Running unit tests...")
     (when (fs/exists? "packages/editor-cljs/shadow-cljs.edn")
       (run-cmd "npx shadow-cljs compile test" :dir "packages/editor-cljs"))

     (when (fs/exists? "packages/lexicon-engine/Cargo.toml")
       (print-step "ğŸ¦€" "Testing Rust...")
       (if (check-command "cargo-nextest")
         (do
           (ensure-dir "test-results/rust")
           (run-cmd "cargo nextest run --profile ci --config-file nextest.toml" :dir "packages/lexicon-engine"))
         (run-cmd "cargo test" :dir "packages/lexicon-engine")))

     (println "")
     (print-step "ğŸŒ" "Running E2E tests...")
     (when (fs/exists? "e2e_tests")
       (run-cmd "clojure -M:e2e -m kaocha.runner --config-file tests.edn"))
     (println "")

     (print-step "âœ…" "All tests completed!"))}

  clean
  {:doc "Clean all build artifacts"
   :task
   (do
     (print-step "ğŸ§¹" "Cleaning build artifacts...")

     (when (fs/exists? "packages/lexicon-engine/wasm/pkg")
       (fs/delete-tree "packages/lexicon-engine/wasm/pkg"))
     (when (fs/exists? "packages/lexicon-engine/wasm/target")
       (fs/delete-tree "packages/lexicon-engine/wasm/target"))

     (when (fs/exists? "packages/editor-cljs/resources/public/js")
       (fs/delete-tree "packages/editor-cljs/resources/public/js"))
     (when (fs/exists? "packages/editor-cljs/.shadow-cljs")
       (fs/delete-tree "packages/editor-cljs/.shadow-cljs"))

     (when (fs/exists? "packages/editor-cljs/resources/public/lexicon-engine")
       (fs/delete-tree "packages/editor-cljs/resources/public/lexicon-engine"))

     (print-step "âœ…" "Clean complete!"))}

  serve
  {:doc "Serve the built application locally for testing"
   :task
   (do
     (print-step "ğŸŒ" "Starting local server...")
     (println "Open http://localhost:8000")
     (println "Press Ctrl+C to stop")
     (run-cmd "python3 -m http.server 8000"
              :dir "packages/editor-cljs/resources/public"))}

  build-and-serve
  {:doc "Build the project and serve it locally"
   :task
   (do
     (install-cljs!)
     (setup-cljs-deps!)
     (build-wasm! "release")
     (build-grammars!)
     (build-cljs! "release")
     (print-step "ğŸ‰" "Full build completed successfully!")
     (print-step "ğŸŒ" "Starting local server...")
     (println "Open http://localhost:8000")
     (println "Press Ctrl+C to stop")
     (run-cmd "python3 -m http.server 8000"
              :dir "packages/editor-cljs/resources/public"))}

  install-act
  {:doc "Install act for local GitHub Actions testing"
   :task
   (do
     (if (check-command "act")
       (println "âœ… act is already installed")
       (do
         (print-step "ğŸ“¦" "Installing act...")
         (println "")
         (println "Choose installation method:")
         (println "  1. Download binary (recommended)")
         (println "  2. Use Nix (if you have nix-shell)")
         (println "")
         (print "Enter choice [1-2]: ")
         (flush)
         (let [choice (read-line)]
           (case choice
             "1" (do
                   (run-cmd "bash -c 'curl https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash'")
                   (print-step "âœ…" "act installed!"))
             "2" (println "Run: nix-shell -p act")
             (println "Invalid choice"))))))}

  act-ci
  {:doc "Run CI workflow locally with act"
   :task
   (do
     (when-not (check-command "act")
       (print-step "âŒ" "act not installed. Run: bb install-act")
       (System/exit 1))

     (print-step "ğŸ¬" "Running CI workflow with act...")
     (println "")
     (println "This will run the GitHub Actions CI workflow in Docker")
     (println "")
     (run-cmd "act pull_request -j test"))}

  act-list
  {:doc "List available GitHub Actions workflows"
   :task
   (do
     (when-not (check-command "act")
       (print-step "âŒ" "act not installed. Run: bb install-act")
       (System/exit 1))

     (run-cmd "act -l"))}

  ci-test
  {:doc "Test CI workflow locally (simulates GitHub Actions)"
   :task
   (do
     (print-step "ğŸ§ª" "Testing CI workflow locally...")
     (println "================================")
     (println "")

     (print-step "ğŸ“‹" "Checking dependencies...")
     (let [node-version (try (str/trim (:out (proc/shell {:out :string} "node --version")))
                            (catch Exception _ "NOT INSTALLED"))
           java-version (try (-> (proc/shell {:out :string} "java -version")
                                :err
                                str/split-lines
                                first)
                            (catch Exception _ "NOT INSTALLED"))
           bb-version (try (str/trim (:out (proc/shell {:out :string} "bb --version")))
                          (catch Exception _ "NOT INSTALLED"))
           rust-version (try (str/trim (:out (proc/shell {:out :string} "rustc --version")))
                            (catch Exception _ "NOT INSTALLED"))
           wasm-pack-version (try (str/trim (:out (proc/shell {:out :string} "wasm-pack --version")))
                                 (catch Exception _ "NOT INSTALLED"))]

       (println (str "  Node.js: " node-version))
       (println (str "  Java: " java-version))
       (println (str "  Babashka: " bb-version))
       (println (str "  Rust: " rust-version))
       (println (str "  wasm-pack: " wasm-pack-version))
       (println "")

       (when (= wasm-pack-version "NOT INSTALLED")
         (print-step "âŒ" "wasm-pack not found. Install it first:")
         (println "   curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh")
         (println "   See: https://rustwasm.github.io/wasm-pack/installer/")
         (System/exit 1)))

     (print-step "ğŸ“¦" "Installing ClojureScript dependencies...")
     (install-cljs!)
     (println "")

     (print-step "ğŸ—ï¸" "Building project...")
     (setup-cljs-deps!)
     (build-wasm! "release")
     (build-grammars!)
     (build-cljs! "release")
     (println "")

     (print-step "ğŸ§ª" "Running tests...")
     (when (fs/exists? "packages/editor-cljs/shadow-cljs.edn")
       (print-step "ğŸ“" "Testing ClojureScript...")
       (run-cmd "npx shadow-cljs compile test" :dir "packages/editor-cljs"))

     (when (fs/exists? "packages/lexicon-engine/Cargo.toml")
       (print-step "ğŸ¦€" "Testing Rust...")
       (if (check-command "cargo-nextest")
         (do
           (ensure-dir "test-results/rust")
           (run-cmd "cargo nextest run --profile ci --config-file nextest.toml" :dir "packages/lexicon-engine"))
         (run-cmd "cargo test" :dir "packages/lexicon-engine")))
     (println "")

     (print-step "âœ…" "All CI steps completed successfully!")
     (println "")
     (println "Your changes should pass CI on GitHub."))}}}
