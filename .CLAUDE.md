# Lexicon Project Memory

**Last Updated:** 2026-01-11
**Status:** Active Development - Phase 7.8.1 Complete, Issue #60 In Progress

---

## Project Mission

**Lexicon is a faithful recreation of GNU Emacs for the modern web.** We implement Emacs's actual architecture (gap buffers, hierarchical keymaps, mode system, command model) using modern technologies (Rust/WASM, ClojureScript, re-frame).

**Core Philosophy:** "When in doubt, do what Emacs does" - We study Emacs source code before implementing features. This is not Emacs-inspired, this IS Emacs for the browser.

---

## üìã Project Tracking - GitHub First!

**‚ö†Ô∏è IMPORTANT: GitHub is the primary source of truth for all project tracking.**

- **Current Work:** Check [open issues](https://github.com/eprapancha/lexicon/issues)
- **Completed Work:** Check [closed issues](https://github.com/eprapancha/lexicon/issues?q=is%3Aissue+is%3Aclosed)
- **Phase Planning:** See issue labels: `phase-7`, `phase-8`, etc.
- **Priorities:** Labels: `priority-high`, `priority-medium`, `priority-low`

**When starting new work:**
1. ‚úÖ Check GitHub issues FIRST - don't rely on this file for status
2. ‚úÖ Create/update GitHub issues for significant work
3. ‚úÖ Reference issue numbers in commits (e.g., `fix(core): resolve bug (#42)`)
4. ‚úÖ Update issue comments with progress, don't just update this file
5. ‚úÖ Close issues when complete, add final summary comment

**This file (.CLAUDE.md) is for:**
- Recent technical learnings (WASM API quirks, architecture decisions)
- Engineering standards and critical rules
- Context that doesn't belong in issues (e.g., "why we made X decision")

---

## Current Phase & Progress

**Completed Phases:**
- ‚úÖ Phases 0-7.7: Core architecture, hooks, undo, markers, dynamic context, package system
- ‚úÖ **Phase 7.8.1:** Minibuffer Architecture Redesign ([#41-55](https://github.com/eprapancha/lexicon/issues?q=is%3Aissue+label%3Aphase-7.8+is%3Aclosed))
  - Implemented *Messages* buffer ([#47](https://github.com/eprapancha/lexicon/issues/47), [#54](https://github.com/eprapancha/lexicon/issues/54))
  - Per-window mode-lines ([#63](https://github.com/eprapancha/lexicon/issues/63))
  - Cursor singleton architecture ([#62](https://github.com/eprapancha/lexicon/issues/62))
  - Emacs-compatible theming ([#55](https://github.com/eprapancha/lexicon/issues/55), [#56](https://github.com/eprapancha/lexicon/issues/56))
  - All minibuffer features (completion UI, dynamic height, echo-area unification)

**Current Work (2026-01-11):**
- üîÑ **Issue #60:** Package Isolation + State Ownership Violations
  - ‚úÖ Phase 1: Fixed 3 minibuffer/echo-area violations
  - ‚úÖ Phase 2: Created `:window/set-mark`, `:window/set-cursor` events, fixed 7 violations
  - ‚úÖ Phase 3: Fixed 1 buffer metadata violation
  - ‚úÖ Phase 4: Documented state ownership rules in db.cljs
  - üìä **Progress:** 11 violations fixed, build passing with 0 warnings

**Open High-Priority Issues:**
- [#61](https://github.com/eprapancha/lexicon/issues/61) - Event-driven test synchronization
- [#60](https://github.com/eprapancha/lexicon/issues/60) - Package isolation from re-frame (in progress)
- [#46](https://github.com/eprapancha/lexicon/issues/46) - Command-specific minibuffer customization

**Next Steps:** See [open issues](https://github.com/eprapancha/lexicon/issues) for current priorities

---

## Recent Technical Learnings

### WASM API (as of 2026-01-04)
- **WasmGapBuffer** is the ONLY WASM interface - simple gap buffer
- Methods: `.insert(pos, text)`, `.delete(pos, length)`, `.getText()`
- Property: `.-length` (NOT a method - use `.-length` not `.getLength()`)
- **WasmEditorCore was deleted** - it was 400+ lines of unused, confusing code
- All variables renamed from `WasmEditorCore` to `WasmGapBuffer` for clarity

### Cursor Position Storage (3 locations)
- `[:ui :cursor-position]` - linear integer position (for WASM operations)
- `[:buffers buffer-id :cursor-position]` - per-buffer line/column {:line N :column M}
- Window's `:cursor-position` - per-window line/column (in window-tree, survives buffer switches)

### Region/Mark System
- **For highlighting during query-replace:** Set mark and cursor on WINDOW, not buffer
- Mark at match start, cursor at match end creates highlighted region
- View layer reads from window's `:mark-position` and `:cursor-position`

### Rust Tests
- **44 tests** in `packages/lexicon-engine/core` (29 GapBuffer + 15 EditorState/PieceTree)
- `packages/lexicon-engine/wasm` has 0 tests (just thin bindings)
- Run from workspace root: `cargo test` in `packages/lexicon-engine`
- JUnit XML via cargo-nextest for CI integration (`nextest.toml` configures output)

### Query-Replace Implementation
- State machine in `[:ui :query-replace]` with fields: `:active?`, `:search-string`, `:replacement-string`, `:current-match`, `:replaced-count`, `:match-history`
- Intercepts ALL keystrokes when active (via `:handle-key-sequence` in keymap.cljs)
- Keys: y/SPC (replace), n/DEL (skip), ! (replace all), q/RET/ESC (quit), ^ (go back), . (replace and quit)
- Creates visual region by setting mark at match start, cursor at match end (both on window)
- History tracking for `^` (go back) functionality

### Circular Dependencies
- `buffer.cljs` and `edit.cljs` cannot both require each other
- Solution: Implement helper functions locally (e.g., `linear-to-line-col` in buffer.cljs) to avoid circular deps

## Architecture Principles

### 0. State Management & Ownership (CRITICAL)

**Problem:** When multiple modules directly manipulate central state, the db becomes a "shared global variable" that everyone reads/writes to. This creates:
- Tight coupling between unrelated modules
- Debugging nightmares ("who changed this?")
- Impossible to trace data flow
- High regression risk
- Violation of encapsulation

**Design Constraint:** Each state variable must be OWNED by exactly ONE module. Other modules MUST dispatch events to the owner.

**State Ownership Map:**
- `:mark-position` ‚Üí OWNED by `edit.cljs` (mark/region commands)
  - Use events: `:set-mark`, `:deactivate-mark`, `:exchange-point-and-mark`
  - ‚ùå NEVER: `(assoc % :mark-position nil)` from query-replace
  - ‚úÖ ALWAYS: `[:dispatch [:deactivate-mark]]` from anywhere

- `:minibuffer` ‚Üí OWNED by `ui.cljs`
  - Use events: `:minibuffer/activate`, `:minibuffer/deactivate`, `:minibuffer/set-input`
  - ‚ùå NEVER: `(assoc db :minibuffer {...})` from isearch
  - ‚úÖ ALWAYS: `[:dispatch [:minibuffer/activate {...}]]`

- `:echo-area` ‚Üí OWNED by `ui.cljs`
  - Use events: `:echo/message`, `:echo/clear`
  - ‚ùå NEVER: `(assoc-in db [:echo-area :message] ...)` from isearch
  - ‚úÖ ALWAYS: `[:dispatch [:echo/message "..."]]`

- `:window-tree` ‚Üí OWNED by `ui.cljs` (window management)
  - Use events: `:window/set-buffer`, `:split-window-below`, `:delete-window`
  - ‚ùå NEVER: `(update :window-tree db/update-window-in-tree ...)` from edit.cljs
  - ‚úÖ ALWAYS: Dispatch events or extract to window management

- `:ui :cursor-position` ‚Üí OWNED by `edit.cljs` (or dedicated cursor module)
  - Use event: `:cursor/set-position` (to be created)
  - ‚ùå NEVER: `(assoc-in db [:ui :cursor-position] ...)` from isearch/buffer
  - ‚úÖ ALWAYS: `[:dispatch [:cursor/set-position pos]]`

- `:buffers` ‚Üí OWNED by `buffer.cljs`
  - Use events for buffer metadata: `:buffer/set-mode`, `:buffer/update-version`, etc.
  - ‚ùå NEVER: `(assoc-in db [:buffers id :major-mode] ...)` from mode.cljs
  - ‚úÖ ALWAYS: `[:dispatch [:buffer/set-mode buffer-id mode]]`

- `:kill-ring` ‚Üí OWNED by `edit.cljs` (kill/yank commands)
  - Only kill/yank commands should update
  - Well-encapsulated, no violations currently

**Enforcement Rules:**
1. **Before adding ANY state update:** Ask "Is this MY state?"
2. **If NO:** Find/create the owner event and dispatch it
3. **If YES:** Document ownership in namespace docstring
4. **Code Reviews:** Reject any PR that violates ownership
5. **Refactoring:** When you see violations, create events immediately

**‚úÖ Fixed Violations (Issue #60 - 2026-01-11):**
- **11 violations fixed** across 4 phases
- Created canonical events:
  - `:window/set-mark` - Update window mark position (ui.cljs owns :window-tree)
  - `:window/set-cursor` - Update window cursor position (ui.cljs owns :window-tree)
- Fixed modules:
  - `buffer.cljs`: 5 violations (minibuffer + query-replace mark/cursor updates)
  - `edit.cljs`: 4 violations (mark management commands)
  - `command.cljs`: 1 violation (echo-area)
  - `message.cljs`: 1 violation (buffer :editor-version)
- **Documentation:** Full state ownership rules documented in `db.cljs`
- **Build status:** ‚úÖ 0 warnings

**Remaining Work:**
- See [Issue #60](https://github.com/eprapancha/lexicon/issues/60) for remaining violations
- Future: Consider moving cursor/mark OUT of window objects (cleaner architecture)

### 1. Userspace/Kernel Split (Emacs C Core / Elisp Layer)

**Rust/WASM "Kernel" (Emacs C core analogy):**
- Gap buffer operations
- UTF-8 text handling
- Performance-critical primitives
- Marker management at engine level

**ClojureScript "Userspace" (Emacs Lisp layer analogy):**
- All user-facing commands (even `self-insert-command`)
- Mode definitions, keymap configurations
- UI rendering (Reagent/React)
- Extensibility and package system

**Rule:** Only functions that need speed go in Rust. Everything else in ClojureScript.

### 2. Core vs Package

**Core** (what you get with `emacs -Q`):
- Buffer/window/frame management
- Keymap system, command dispatcher
- Mode system (major/minor)
- Minibuffer, basic editing
- File I/O, kill ring

**Packages** (external, loadable):
- Evil-mode (vim emulation)
- Vertico/Orderless/Consult (completion)
- Syntax highlighting (beyond basic)
- LSP integration
- Themes

**Rule:** If Emacs doesn't have it by default, it's a package.

### 3. Key Technical Decisions

- **Gap buffer** (not piece tree) - simpler, faster for localized edits, aligns with Emacs
- **Hierarchical keymaps** - exact Emacs precedence order
- **One major mode, many minor modes** per buffer
- **Package system** - git-first, SCI sandbox for untrusted code
- **Elisp compatibility** - reuse Emacs packages instead of rewriting (Phase 7.9+)

---

## Engineering Standards

### Testing Requirements

**Test Coverage Expectations:**
- ‚úÖ **Rust code:** Unit tests required for all public functions
- ‚úÖ **E2E tests:** All user-facing features must have E2E tests
- ‚úÖ **Test-first when possible:** Write tests before implementation for new features
- ‚úÖ **No regressions:** All tests must pass before commit

**Running Tests:**
```bash
# During development
bb test:unit:watch        # Continuous ClojureScript tests

# Before commit
cargo test                # Rust unit tests (in packages/lexicon-engine/wasm)
bb test:e2e               # E2E tests (requires app running at :8080)
bb test                   # All tests (unit + E2E + Rust)
```

**Test Requirements:**
- Add tests when implementing new features (Phase 7.7+)
- Add tests when fixing bugs (regression tests)
- E2E tests cover critical user workflows
- Rust unit tests for gap buffer operations

### Code Organization & Hygiene

**File Size Limits:**
- ‚úÖ **Max ~500 lines per namespace** - Split larger files into focused modules
- ‚úÖ **Example:** `events.cljs` refactored from 2,958 lines ‚Üí 7 modules (~400 lines each)

**Namespace Organization:**
```clojure
packages/editor-cljs/src/lexicon/
‚îú‚îÄ‚îÄ core.cljs              # Main entry point
‚îú‚îÄ‚îÄ db.cljs                # App-db schema
‚îú‚îÄ‚îÄ events/                # Event handlers (by domain)
‚îÇ   ‚îú‚îÄ‚îÄ buffer.cljs
‚îÇ   ‚îú‚îÄ‚îÄ command.cljs
‚îÇ   ‚îú‚îÄ‚îÄ edit.cljs
‚îÇ   ‚îú‚îÄ‚îÄ file.cljs
‚îÇ   ‚îú‚îÄ‚îÄ navigation.cljs
‚îÇ   ‚îú‚îÄ‚îÄ window.cljs
‚îÇ   ‚îî‚îÄ‚îÄ wasm.cljs
‚îú‚îÄ‚îÄ subs.cljs              # Subscriptions
‚îú‚îÄ‚îÄ views.cljs             # UI components
‚îú‚îÄ‚îÄ hooks.cljs             # Hook system
‚îú‚îÄ‚îÄ markers.cljs           # Marker abstraction
‚îú‚îÄ‚îÄ context.cljs           # Dynamic execution context
‚îî‚îÄ‚îÄ advanced_undo.cljs     # Undo system
```

**Rules:**
- Group related functions in same namespace
- Separate concerns (events, subs, views, business logic)
- Use descriptive namespace names
- Refactor when file exceeds ~500 lines

**Code Complexity:**
- Favor small, focused functions over large ones
- Extract helper functions to reduce nesting
- Use meaningful variable names
- Add docstrings to public APIs

**Code Reusability:**
- Extract common patterns into utility functions
- Avoid copy-paste - refactor duplicated code
- Use ClojureScript idioms (destructuring, threading macros)
- Share utilities across namespaces via dedicated files

### Critical Rules - READ FIRST

**‚ö†Ô∏è NEVER Run Compilation or Dev Servers:**
- ‚ùå NEVER run `bb dev` or any dev server
- ‚ùå NEVER run `npx shadow-cljs compile/watch`
- ‚ùå NEVER run `cargo build` or `wasm-pack build`
- ‚ùå NEVER run background compilation processes
- ‚ùå NEVER run tests in background where output is hidden

**Why:** User ALWAYS has a watch process running. They need full visibility of compilation output to catch warnings/errors immediately. Running compilation yourself hides critical warnings and leads to "everything is fine" false reports.

**Your Role:** Only write code. If user doesn't report compilation issues, assume everything compiles fine.

**Golden Rules:**
- ‚úÖ NEVER commit code that doesn't compile cleanly
- ‚úÖ NEVER ignore compilation warnings
- ‚úÖ If you don't see compilation output, don't assume it worked
- ‚úÖ User will report compilation errors when they occur
- ‚úÖ Ask before adding new learnings to project memory

### Commit Hygiene

**Commit Frequency:**
- ‚úÖ **Commit after each green test run** - Keep commits small and atomic
- ‚úÖ **Commit after completing each step** in roadmap tasks
- ‚úÖ **Commit format:**
  ```
  type(scope): concise description

  - Detailed bullet points
  - Explain what and why, not how
  - Reference phase/step if applicable

  ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

  Co-Authored-By: Claude <noreply@anthropic.com>
  ```

**Commit Types:**
- `feat` - New feature
- `fix` - Bug fix
- `refactor` - Code restructuring (no behavior change)
- `test` - Add/modify tests
- `docs` - Documentation only
- `deps` - Dependency updates
- `ci` - CI/CD changes

**Before Every Commit:**
```bash
# 1. Ensure code compiles
npx shadow-cljs compile app    # ClojureScript
cargo build                     # Rust

# 2. Run tests
cargo test                      # Rust tests
bb test:e2e                     # E2E tests (if applicable)

# 3. Check for warnings
# Fix all warnings before committing - zero tolerance for warnings
```

### Babashka Task Conventions

**Task Naming:**
- Use kebab-case for task names
- Prefix composite tasks with `:` (e.g., `test:unit`, `test:e2e`)
- Add emoji to print-step messages for visual clarity

**Task Documentation:**
- All tasks must have `:doc` string
- Use `print-step` for progress indication:
  ```clojure
  (print-step "üöÄ" "Starting build...")
  (print-step "‚úÖ" "Build complete!")
  (print-step "‚ùå" "Build failed!")
  ```

**Common Tasks:**
```bash
bb dev              # Start development server
bb build            # Full production build
bb test             # Run all tests
bb clean            # Clean build artifacts
bb ci-test          # Simulate CI locally
```

---

## Development Workflow

### Daily Development

```bash
# 1. Start development server
bb dev              # Frontend at http://localhost:8080

# 2. Make changes, verify live reload works

# 3. Before commit:
cargo test          # Rust tests
npx shadow-cljs compile app  # Ensure no warnings
bb test:e2e         # E2E tests (if applicable)

# 4. Commit with descriptive message
git add -A
git commit -m "feat(markers): add overlay marker support"
```

### Debugging Workflow

**Using git diff for Regressions:**
```bash
# Find what changed to cause regression
git diff HEAD~5    # Check last 5 commits
git diff <hash>    # Specific commit

# Bisect to find breaking commit
git bisect start
git bisect bad                    # Current state is bad
git bisect good <known-good>      # Last known good commit
# Git will checkout commits - test each with `bb test`
git bisect good/bad  # Mark each commit
git bisect reset     # When done

# View file-specific changes
git log -p -- path/to/file.cljs
git blame path/to/file.cljs  # Line-by-line attribution
```

**Using Browser DevTools:**
- Check ClojureScript console for errors
- Use re-frame-10x for state inspection (if enabled)
- Network tab for WASM loading issues

**Using Rust Debugging:**
```bash
# Run Rust tests with output
cargo test -- --nocapture

# Run specific test
cargo test test_marker_creation -- --nocapture
```

---

## Security Considerations

### Package Trust Model (Phase 7.7+)

**Trust Levels:**
- **:core** - Built-in packages, full access, native eval
- **:local** - User-installed from filesystem, full access, native eval
- **:external** - Third-party from internet, **SCI sandbox only**, Core API only

**Rules:**
- External packages CANNOT access editor internals
- External packages CANNOT use arbitrary `js/*` access
- External packages can ONLY use Core API functions
- Package load failures must NOT crash editor

### Elisp Compatibility Strategy (Phase 7.9+)

**Problem:** Reimplementing mature Emacs packages (orderless, consult, embark) from scratch is:
- Time-prohibitive (months per package)
- Never achieves feature parity
- Constant divergence from upstream

**Solution:** Restricted Elisp compatibility layer on top of SCI:
- Parse Elisp source to AST
- Evaluate with Elisp semantics in SCI
- Map Elisp primitives to Lexicon Core API
- Reuse package logic, replace UI integration

**Non-Goals** (Critical):
- ‚ùå Full Emacs compatibility
- ‚ùå Bytecode interpretation
- ‚ùå Overlays, text properties
- ‚ùå Drop-in compatibility

**Goals** (Realistic):
- ‚úÖ Reuse filtering/matching logic
- ‚úÖ Run utility libraries (dash, s)
- ‚úÖ Load orderless, partial consult/embark
- ‚úÖ Track upstream automatically

**Strategic Alignment:**
- "Do what Emacs does" - literally run Emacs code
- Unlocks hundreds of existing packages
- Preserves user muscle memory
- SCI infrastructure already in place

**Reference:** `docs/ELISP_COMPATIBILITY.md` for full feasibility study

### General Security

- Validate all user input (file paths, URLs)
- Sanitize data before rendering (prevent XSS)
- No `eval` on untrusted code (use SCI for external packages)
- Clear error messages without leaking internals

---

## Performance Standards

### Expectations

- ‚úÖ **Editor startup:** < 2 seconds
- ‚úÖ **Command execution:** < 16ms (60 FPS)
- ‚úÖ **File loading:** < 1 second for 10k line files
- ‚úÖ **Package loading:** < 100ms per package (warn if slower)

### Optimization Guidelines

- Profile before optimizing (use browser profiler)
- Gap buffer operations in Rust for speed
- Minimize re-renders (use React.memo, memoize subscriptions)
- Lazy load packages when possible
- Use web workers for heavy computation (future)

### Monitoring

- Log package initialization time (Phase 7.7+)
- Warn if package load > 100ms
- Track command execution time in development

---

## Logging Standards

### When to Log

**Console Logs (Development):**
```clojure
(js/console.log "üé® Updating stylesheet:" id)
(js/console.warn "‚ö†Ô∏è Package load slow:" package-name time-ms)
(js/console.error "‚ùå Hook failed:" hook-id error)
```

**Echo Area (User-Facing):**
```clojure
[:dispatch [:echo/message "Loaded package: vertico"]]
[:dispatch [:show-error "Failed to load package"]]
```

**Structured Logging (Phase 12+):**
- Package lifecycle events (load, unload, enable, disable)
- Package evaluation events (success, failure)
- Performance warnings (slow operations)

### Log Levels

- **Info:** Normal operations (package loaded, command executed)
- **Warn:** Non-critical issues (slow package, deprecated API)
- **Error:** Failures that don't crash (package load failed, hook error)

---

## Key Files & Documentation

**Must Read:**
- `docs/ROADMAP.md` - Phased development plan (THE source of truth)
- `docs/CORE_PRINCIPLES.md` - Architectural philosophy
- `README.md` - Project overview

**Architecture:**
- `docs/architecture.md` - Technical architecture details
- `docs/core/*.md` - Core API contracts (Phase 7+)

**Development:**
- `bb.edn` - Build tasks and tooling
- `packages/editor-cljs/shadow-cljs.edn` - ClojureScript build config
- `packages/lexicon-engine/wasm/Cargo.toml` - Rust dependencies

---

## Common Patterns

### Re-frame Event Pattern

```clojure
(rf/reg-event-fx
  :namespace/action
  (fn [{:keys [db]} [_ arg1 arg2]]
    {:db (update-in db [:path :to :data] f)
     :fx [[:dispatch [:other-event arg1]]
          [:dom/focus-editor]]}))
```

### Re-frame Subscription Pattern

```clojure
(rf/reg-sub
  :namespace/data
  (fn [db [_ id]]
    (get-in db [:path :to :data id])))
```

### Adding New Command

```clojure
;; 1. Define event handler
(rf/reg-event-fx
  :my-command
  (fn [{:keys [db]} [_]]
    {:db (assoc-in db [:some :state] value)}))

;; 2. Register command
(rf/dispatch [:register-command :my-command
              {:docstring "Description"
               :handler [:my-command]}])

;; 3. Bind to keymap
(rf/dispatch [:define-key :global "C-c m" :my-command])

;; 4. Add E2E test
(deftest test-my-command
  (is (= expected-result (execute-command :my-command))))
```

---

## Troubleshooting

### Build Issues

**WASM fails to compile:**
```bash
cd packages/lexicon-engine/wasm
cargo clean
cargo build
wasm-pack build --target web
```

**ClojureScript fails to compile:**
```bash
cd packages/editor-cljs
rm -rf .shadow-cljs
rm -rf resources/public/js
npx shadow-cljs compile app
```

### Test Issues

**E2E tests fail:**
1. Ensure app is running at http://localhost:8080 (`bb dev`)
2. Ensure Firefox is installed
3. Check test logs for specific failures

**Rust tests fail:**
```bash
cd packages/lexicon-engine/wasm
cargo test -- --nocapture
# Look for specific assertion failures
```

### Git Issues

**Merge conflicts:**
```bash
# View conflicts
git status

# Resolve manually, then:
git add <resolved-files>
git commit
```

**Revert bad commit:**
```bash
git revert <commit-hash>  # Creates new commit that undoes changes
# OR
git reset --hard <good-commit>  # DANGEROUS: loses history
```

---

## Quick Reference

### Key Commands

```bash
# Development
bb dev                   # Start dev server
bb test                  # Run all tests
bb clean                 # Clean build artifacts

# Testing
cargo test               # Rust unit tests
bb test:e2e              # E2E tests
bb test:unit:watch       # Watch mode for unit tests

# Building
bb build                 # Production build
bb build-dev             # Development build
bb build-wasm            # Just WASM
bb build-cljs            # Just ClojureScript

# Debugging
git diff HEAD~3          # View recent changes
git log -p -- <file>     # File history with diffs
git bisect               # Find breaking commit
```

### Important Paths

```
packages/editor-cljs/src/lexicon/     # ClojureScript source
packages/lexicon-engine/core/         # Rust gap buffer
packages/lexicon-engine/wasm/         # WASM bindings
e2e_tests/                            # E2E tests
docs/                                 # Documentation
```

---

## Remember

1. ‚úÖ **Test first** - Write tests, then implement
2. ‚úÖ **Commit frequently** - After each green test run
3. ‚úÖ **No warnings** - Fix all warnings before commit
4. ‚úÖ **Small functions** - Refactor when file > 500 lines
5. ‚úÖ **Emacs fidelity** - When in doubt, check Emacs source
6. ‚úÖ **Document as you go** - Update ROADMAP.md when completing phases
7. ‚úÖ **Zero regressions** - All tests must pass
8. ‚úÖ **Git for debugging** - Use `git diff` and `git bisect` to find regressions

---

**This file survives conversation compactions. Keep it updated with new patterns and decisions.**
