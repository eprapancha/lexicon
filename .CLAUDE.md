# Lexicon Project Memory

**Last Updated:** 2026-01-04
**Status:** Active Development - Phase 7.8 In Progress (query-replace implementation)

---

## Project Mission

**Lexicon is a faithful recreation of GNU Emacs for the modern web.** We implement Emacs's actual architecture (gap buffers, hierarchical keymaps, mode system, command model) using modern technologies (Rust/WASM, ClojureScript, re-frame).

**Core Philosophy:** "When in doubt, do what Emacs does" - We study Emacs source code before implementing features. This is not Emacs-inspired, this IS Emacs for the browser.

---

## Current Phase & Progress

**Completed:**
- ‚úÖ Phases 0-7.7: Core architecture, event system refactoring, hooks, undo, markers, dynamic context, package system
- ‚úÖ Phase 7.5: First-class markers (engine-level in Rust, ClojureScript API)
- ‚úÖ Phase 7.6: Dynamic execution context (Emacs-style dynamic scope)
- ‚úÖ Phase 7.7: Package system, SCI integration, trust model, loader

**Current Phase:** Phase 7.8 - Search & Replace Commands
**In Progress:**
- ‚úÖ `query-replace` (M-%) basic implementation with interactive keys (y/n/!/q/^/.)
- ‚úÖ `query-replace-regexp` (C-M-%)
- ‚úÖ Cursor movement and region highlighting during replacements
- ‚úÖ WASM API cleanup (removed WasmEditorCore, fixed all API calls)
- ‚úÖ Rust test infrastructure (44 tests now run correctly, JUnit XML reporting added)
- üîÑ Fixing remaining E2E test failures (5 failures as of latest run)
- üîÑ Manual testing against Emacs for zero deviation
- üîÑ Cleanup verbose debug logging

**Next Steps:**
1. Complete Phase 7.8 (fix bugs, cleanup, test)
2. Documentation consolidation (see plan below)
3. Update ManualTestingPlan.md with all new features
4. Comprehensive manual testing side-by-side with Emacs
5. Create/update E2E automation tests
6. Phase 7.9 (Elisp compat) ‚Üí Phase 8 (orderless/vertico/consult)

**Reference:** `docs/ROADMAP.md` for detailed phase breakdown

---

## Documentation Consolidation Plan (After Phase 7.8)

**Problem:** Status tracking and architectural principles scattered across 5-6 files causing confusion, overlaps, and no single source of truth.

**Solution:**

### 1. GitHub Projects for Status Tracking
- Create GitHub Project board for phase tracking
- Create milestones per phase
- Create issues for specific tasks
- Use GitHub as THE status tracker (not markdown files)

### 2. Single Source of Truth for Architecture
- **docs/CORE_PRINCIPLES.md** = THE architectural philosophy source
  - Consolidate from: architecture.md, ELISP_COMPATIBILITY.md, parts of README.md
  - Keep focused on WHY decisions were made
  - Reference from other docs

### 3. Single Source of Truth for Phases
- **docs/ROADMAP.md** = THE phase tracker
  - Keep as single source for phase breakdown
  - Link to GitHub issues for detailed status
  - Don't duplicate status here

### 4. Minimal, Link-Heavy README
- **README.md** = Project overview + navigation
  - Brief intro
  - Links to docs/CORE_PRINCIPLES.md
  - Links to docs/ROADMAP.md
  - Links to GitHub Projects
  - Development quickstart
  - No duplication

### 5. .CLAUDE.md for AI Context Only
- Keep current learnings (WASM API, cursor positions, etc.)
  - Engineering rules (NEVER compile, etc.)
- Link to other docs, don't duplicate
- Slightly longer context is fine if needed

### 6. Archive Old Content
- Move chatgpt_review.md to docs/archive/
- Remove outdated phase-specific implementation plans after completion
- Keep EmacsReferenceCard.md as reference

**Implementation:**
- Do this AFTER Phase 7.8 is complete
- Create GitHub Project first
- Then consolidate docs
- Update .CLAUDE.md last

---

## Recent Technical Learnings

### WASM API (as of 2026-01-04)
- **WasmGapBuffer** is the ONLY WASM interface - simple gap buffer
- Methods: `.insert(pos, text)`, `.delete(pos, length)`, `.getText()`
- Property: `.-length` (NOT a method - use `.-length` not `.getLength()`)
- **WasmEditorCore was deleted** - it was 400+ lines of unused, confusing code
- All variables renamed from `WasmEditorCore` to `WasmGapBuffer` for clarity

### Cursor Position Storage (3 locations)
- `[:ui :cursor-position]` - linear integer position (for WASM operations)
- `[:buffers buffer-id :cursor-position]` - per-buffer line/column {:line N :column M}
- Window's `:cursor-position` - per-window line/column (in window-tree, survives buffer switches)

### Region/Mark System
- **For highlighting during query-replace:** Set mark and cursor on WINDOW, not buffer
- Mark at match start, cursor at match end creates highlighted region
- View layer reads from window's `:mark-position` and `:cursor-position`

### Rust Tests
- **44 tests** in `packages/lexicon-engine/core` (29 GapBuffer + 15 EditorState/PieceTree)
- `packages/lexicon-engine/wasm` has 0 tests (just thin bindings)
- Run from workspace root: `cargo test` in `packages/lexicon-engine`
- JUnit XML via cargo-nextest for CI integration (`nextest.toml` configures output)

### Query-Replace Implementation
- State machine in `[:ui :query-replace]` with fields: `:active?`, `:search-string`, `:replacement-string`, `:current-match`, `:replaced-count`, `:match-history`
- Intercepts ALL keystrokes when active (via `:handle-key-sequence` in keymap.cljs)
- Keys: y/SPC (replace), n/DEL (skip), ! (replace all), q/RET/ESC (quit), ^ (go back), . (replace and quit)
- Creates visual region by setting mark at match start, cursor at match end (both on window)
- History tracking for `^` (go back) functionality

### Circular Dependencies
- `buffer.cljs` and `edit.cljs` cannot both require each other
- Solution: Implement helper functions locally (e.g., `linear-to-line-col` in buffer.cljs) to avoid circular deps

## Architecture Principles

### 1. Userspace/Kernel Split (Emacs C Core / Elisp Layer)

**Rust/WASM "Kernel" (Emacs C core analogy):**
- Gap buffer operations
- UTF-8 text handling
- Performance-critical primitives
- Marker management at engine level

**ClojureScript "Userspace" (Emacs Lisp layer analogy):**
- All user-facing commands (even `self-insert-command`)
- Mode definitions, keymap configurations
- UI rendering (Reagent/React)
- Extensibility and package system

**Rule:** Only functions that need speed go in Rust. Everything else in ClojureScript.

### 2. Core vs Package

**Core** (what you get with `emacs -Q`):
- Buffer/window/frame management
- Keymap system, command dispatcher
- Mode system (major/minor)
- Minibuffer, basic editing
- File I/O, kill ring

**Packages** (external, loadable):
- Evil-mode (vim emulation)
- Vertico/Orderless/Consult (completion)
- Syntax highlighting (beyond basic)
- LSP integration
- Themes

**Rule:** If Emacs doesn't have it by default, it's a package.

### 3. Key Technical Decisions

- **Gap buffer** (not piece tree) - simpler, faster for localized edits, aligns with Emacs
- **Hierarchical keymaps** - exact Emacs precedence order
- **One major mode, many minor modes** per buffer
- **Package system** - git-first, SCI sandbox for untrusted code
- **Elisp compatibility** - reuse Emacs packages instead of rewriting (Phase 7.9+)

---

## Engineering Standards

### Testing Requirements

**Test Coverage Expectations:**
- ‚úÖ **Rust code:** Unit tests required for all public functions
- ‚úÖ **E2E tests:** All user-facing features must have E2E tests
- ‚úÖ **Test-first when possible:** Write tests before implementation for new features
- ‚úÖ **No regressions:** All tests must pass before commit

**Running Tests:**
```bash
# During development
bb test:unit:watch        # Continuous ClojureScript tests

# Before commit
cargo test                # Rust unit tests (in packages/lexicon-engine/wasm)
bb test:e2e               # E2E tests (requires app running at :8080)
bb test                   # All tests (unit + E2E + Rust)
```

**Test Requirements:**
- Add tests when implementing new features (Phase 7.7+)
- Add tests when fixing bugs (regression tests)
- E2E tests cover critical user workflows
- Rust unit tests for gap buffer operations

### Code Organization & Hygiene

**File Size Limits:**
- ‚úÖ **Max ~500 lines per namespace** - Split larger files into focused modules
- ‚úÖ **Example:** `events.cljs` refactored from 2,958 lines ‚Üí 7 modules (~400 lines each)

**Namespace Organization:**
```clojure
packages/editor-cljs/src/lexicon/
‚îú‚îÄ‚îÄ core.cljs              # Main entry point
‚îú‚îÄ‚îÄ db.cljs                # App-db schema
‚îú‚îÄ‚îÄ events/                # Event handlers (by domain)
‚îÇ   ‚îú‚îÄ‚îÄ buffer.cljs
‚îÇ   ‚îú‚îÄ‚îÄ command.cljs
‚îÇ   ‚îú‚îÄ‚îÄ edit.cljs
‚îÇ   ‚îú‚îÄ‚îÄ file.cljs
‚îÇ   ‚îú‚îÄ‚îÄ navigation.cljs
‚îÇ   ‚îú‚îÄ‚îÄ window.cljs
‚îÇ   ‚îî‚îÄ‚îÄ wasm.cljs
‚îú‚îÄ‚îÄ subs.cljs              # Subscriptions
‚îú‚îÄ‚îÄ views.cljs             # UI components
‚îú‚îÄ‚îÄ hooks.cljs             # Hook system
‚îú‚îÄ‚îÄ markers.cljs           # Marker abstraction
‚îú‚îÄ‚îÄ context.cljs           # Dynamic execution context
‚îî‚îÄ‚îÄ advanced_undo.cljs     # Undo system
```

**Rules:**
- Group related functions in same namespace
- Separate concerns (events, subs, views, business logic)
- Use descriptive namespace names
- Refactor when file exceeds ~500 lines

**Code Complexity:**
- Favor small, focused functions over large ones
- Extract helper functions to reduce nesting
- Use meaningful variable names
- Add docstrings to public APIs

**Code Reusability:**
- Extract common patterns into utility functions
- Avoid copy-paste - refactor duplicated code
- Use ClojureScript idioms (destructuring, threading macros)
- Share utilities across namespaces via dedicated files

### Critical Rules - READ FIRST

**‚ö†Ô∏è NEVER Run Compilation or Dev Servers:**
- ‚ùå NEVER run `bb dev` or any dev server
- ‚ùå NEVER run `npx shadow-cljs compile/watch`
- ‚ùå NEVER run `cargo build` or `wasm-pack build`
- ‚ùå NEVER run background compilation processes
- ‚ùå NEVER run tests in background where output is hidden

**Why:** User ALWAYS has a watch process running. They need full visibility of compilation output to catch warnings/errors immediately. Running compilation yourself hides critical warnings and leads to "everything is fine" false reports.

**Your Role:** Only write code. If user doesn't report compilation issues, assume everything compiles fine.

**Golden Rules:**
- ‚úÖ NEVER commit code that doesn't compile cleanly
- ‚úÖ NEVER ignore compilation warnings
- ‚úÖ If you don't see compilation output, don't assume it worked
- ‚úÖ User will report compilation errors when they occur
- ‚úÖ Ask before adding new learnings to project memory

### Commit Hygiene

**Commit Frequency:**
- ‚úÖ **Commit after each green test run** - Keep commits small and atomic
- ‚úÖ **Commit after completing each step** in roadmap tasks
- ‚úÖ **Commit format:**
  ```
  type(scope): concise description

  - Detailed bullet points
  - Explain what and why, not how
  - Reference phase/step if applicable

  ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

  Co-Authored-By: Claude <noreply@anthropic.com>
  ```

**Commit Types:**
- `feat` - New feature
- `fix` - Bug fix
- `refactor` - Code restructuring (no behavior change)
- `test` - Add/modify tests
- `docs` - Documentation only
- `deps` - Dependency updates
- `ci` - CI/CD changes

**Before Every Commit:**
```bash
# 1. Ensure code compiles
npx shadow-cljs compile app    # ClojureScript
cargo build                     # Rust

# 2. Run tests
cargo test                      # Rust tests
bb test:e2e                     # E2E tests (if applicable)

# 3. Check for warnings
# Fix all warnings before committing - zero tolerance for warnings
```

### Babashka Task Conventions

**Task Naming:**
- Use kebab-case for task names
- Prefix composite tasks with `:` (e.g., `test:unit`, `test:e2e`)
- Add emoji to print-step messages for visual clarity

**Task Documentation:**
- All tasks must have `:doc` string
- Use `print-step` for progress indication:
  ```clojure
  (print-step "üöÄ" "Starting build...")
  (print-step "‚úÖ" "Build complete!")
  (print-step "‚ùå" "Build failed!")
  ```

**Common Tasks:**
```bash
bb dev              # Start development server
bb build            # Full production build
bb test             # Run all tests
bb clean            # Clean build artifacts
bb ci-test          # Simulate CI locally
```

---

## Development Workflow

### Daily Development

```bash
# 1. Start development server
bb dev              # Frontend at http://localhost:8080

# 2. Make changes, verify live reload works

# 3. Before commit:
cargo test          # Rust tests
npx shadow-cljs compile app  # Ensure no warnings
bb test:e2e         # E2E tests (if applicable)

# 4. Commit with descriptive message
git add -A
git commit -m "feat(markers): add overlay marker support"
```

### Debugging Workflow

**Using git diff for Regressions:**
```bash
# Find what changed to cause regression
git diff HEAD~5    # Check last 5 commits
git diff <hash>    # Specific commit

# Bisect to find breaking commit
git bisect start
git bisect bad                    # Current state is bad
git bisect good <known-good>      # Last known good commit
# Git will checkout commits - test each with `bb test`
git bisect good/bad  # Mark each commit
git bisect reset     # When done

# View file-specific changes
git log -p -- path/to/file.cljs
git blame path/to/file.cljs  # Line-by-line attribution
```

**Using Browser DevTools:**
- Check ClojureScript console for errors
- Use re-frame-10x for state inspection (if enabled)
- Network tab for WASM loading issues

**Using Rust Debugging:**
```bash
# Run Rust tests with output
cargo test -- --nocapture

# Run specific test
cargo test test_marker_creation -- --nocapture
```

---

## Security Considerations

### Package Trust Model (Phase 7.7+)

**Trust Levels:**
- **:core** - Built-in packages, full access, native eval
- **:local** - User-installed from filesystem, full access, native eval
- **:external** - Third-party from internet, **SCI sandbox only**, Core API only

**Rules:**
- External packages CANNOT access editor internals
- External packages CANNOT use arbitrary `js/*` access
- External packages can ONLY use Core API functions
- Package load failures must NOT crash editor

### Elisp Compatibility Strategy (Phase 7.9+)

**Problem:** Reimplementing mature Emacs packages (orderless, consult, embark) from scratch is:
- Time-prohibitive (months per package)
- Never achieves feature parity
- Constant divergence from upstream

**Solution:** Restricted Elisp compatibility layer on top of SCI:
- Parse Elisp source to AST
- Evaluate with Elisp semantics in SCI
- Map Elisp primitives to Lexicon Core API
- Reuse package logic, replace UI integration

**Non-Goals** (Critical):
- ‚ùå Full Emacs compatibility
- ‚ùå Bytecode interpretation
- ‚ùå Overlays, text properties
- ‚ùå Drop-in compatibility

**Goals** (Realistic):
- ‚úÖ Reuse filtering/matching logic
- ‚úÖ Run utility libraries (dash, s)
- ‚úÖ Load orderless, partial consult/embark
- ‚úÖ Track upstream automatically

**Strategic Alignment:**
- "Do what Emacs does" - literally run Emacs code
- Unlocks hundreds of existing packages
- Preserves user muscle memory
- SCI infrastructure already in place

**Reference:** `docs/ELISP_COMPATIBILITY.md` for full feasibility study

### General Security

- Validate all user input (file paths, URLs)
- Sanitize data before rendering (prevent XSS)
- No `eval` on untrusted code (use SCI for external packages)
- Clear error messages without leaking internals

---

## Performance Standards

### Expectations

- ‚úÖ **Editor startup:** < 2 seconds
- ‚úÖ **Command execution:** < 16ms (60 FPS)
- ‚úÖ **File loading:** < 1 second for 10k line files
- ‚úÖ **Package loading:** < 100ms per package (warn if slower)

### Optimization Guidelines

- Profile before optimizing (use browser profiler)
- Gap buffer operations in Rust for speed
- Minimize re-renders (use React.memo, memoize subscriptions)
- Lazy load packages when possible
- Use web workers for heavy computation (future)

### Monitoring

- Log package initialization time (Phase 7.7+)
- Warn if package load > 100ms
- Track command execution time in development

---

## Logging Standards

### When to Log

**Console Logs (Development):**
```clojure
(js/console.log "üé® Updating stylesheet:" id)
(js/console.warn "‚ö†Ô∏è Package load slow:" package-name time-ms)
(js/console.error "‚ùå Hook failed:" hook-id error)
```

**Echo Area (User-Facing):**
```clojure
[:dispatch [:echo/message "Loaded package: vertico"]]
[:dispatch [:show-error "Failed to load package"]]
```

**Structured Logging (Phase 12+):**
- Package lifecycle events (load, unload, enable, disable)
- Package evaluation events (success, failure)
- Performance warnings (slow operations)

### Log Levels

- **Info:** Normal operations (package loaded, command executed)
- **Warn:** Non-critical issues (slow package, deprecated API)
- **Error:** Failures that don't crash (package load failed, hook error)

---

## Key Files & Documentation

**Must Read:**
- `docs/ROADMAP.md` - Phased development plan (THE source of truth)
- `docs/CORE_PRINCIPLES.md` - Architectural philosophy
- `README.md` - Project overview

**Architecture:**
- `docs/architecture.md` - Technical architecture details
- `docs/core/*.md` - Core API contracts (Phase 7+)

**Development:**
- `bb.edn` - Build tasks and tooling
- `packages/editor-cljs/shadow-cljs.edn` - ClojureScript build config
- `packages/lexicon-engine/wasm/Cargo.toml` - Rust dependencies

---

## Common Patterns

### Re-frame Event Pattern

```clojure
(rf/reg-event-fx
  :namespace/action
  (fn [{:keys [db]} [_ arg1 arg2]]
    {:db (update-in db [:path :to :data] f)
     :fx [[:dispatch [:other-event arg1]]
          [:dom/focus-editor]]}))
```

### Re-frame Subscription Pattern

```clojure
(rf/reg-sub
  :namespace/data
  (fn [db [_ id]]
    (get-in db [:path :to :data id])))
```

### Adding New Command

```clojure
;; 1. Define event handler
(rf/reg-event-fx
  :my-command
  (fn [{:keys [db]} [_]]
    {:db (assoc-in db [:some :state] value)}))

;; 2. Register command
(rf/dispatch [:register-command :my-command
              {:docstring "Description"
               :handler [:my-command]}])

;; 3. Bind to keymap
(rf/dispatch [:define-key :global "C-c m" :my-command])

;; 4. Add E2E test
(deftest test-my-command
  (is (= expected-result (execute-command :my-command))))
```

---

## Troubleshooting

### Build Issues

**WASM fails to compile:**
```bash
cd packages/lexicon-engine/wasm
cargo clean
cargo build
wasm-pack build --target web
```

**ClojureScript fails to compile:**
```bash
cd packages/editor-cljs
rm -rf .shadow-cljs
rm -rf resources/public/js
npx shadow-cljs compile app
```

### Test Issues

**E2E tests fail:**
1. Ensure app is running at http://localhost:8080 (`bb dev`)
2. Ensure Firefox is installed
3. Check test logs for specific failures

**Rust tests fail:**
```bash
cd packages/lexicon-engine/wasm
cargo test -- --nocapture
# Look for specific assertion failures
```

### Git Issues

**Merge conflicts:**
```bash
# View conflicts
git status

# Resolve manually, then:
git add <resolved-files>
git commit
```

**Revert bad commit:**
```bash
git revert <commit-hash>  # Creates new commit that undoes changes
# OR
git reset --hard <good-commit>  # DANGEROUS: loses history
```

---

## Quick Reference

### Key Commands

```bash
# Development
bb dev                   # Start dev server
bb test                  # Run all tests
bb clean                 # Clean build artifacts

# Testing
cargo test               # Rust unit tests
bb test:e2e              # E2E tests
bb test:unit:watch       # Watch mode for unit tests

# Building
bb build                 # Production build
bb build-dev             # Development build
bb build-wasm            # Just WASM
bb build-cljs            # Just ClojureScript

# Debugging
git diff HEAD~3          # View recent changes
git log -p -- <file>     # File history with diffs
git bisect               # Find breaking commit
```

### Important Paths

```
packages/editor-cljs/src/lexicon/     # ClojureScript source
packages/lexicon-engine/core/         # Rust gap buffer
packages/lexicon-engine/wasm/         # WASM bindings
e2e_tests/                            # E2E tests
docs/                                 # Documentation
```

---

## Remember

1. ‚úÖ **Test first** - Write tests, then implement
2. ‚úÖ **Commit frequently** - After each green test run
3. ‚úÖ **No warnings** - Fix all warnings before commit
4. ‚úÖ **Small functions** - Refactor when file > 500 lines
5. ‚úÖ **Emacs fidelity** - When in doubt, check Emacs source
6. ‚úÖ **Document as you go** - Update ROADMAP.md when completing phases
7. ‚úÖ **Zero regressions** - All tests must pass
8. ‚úÖ **Git for debugging** - Use `git diff` and `git bisect` to find regressions

---

**This file survives conversation compactions. Keep it updated with new patterns and decisions.**
