# Lexicon Project Memory

**Last Updated:** 2026-01-03
**Status:** Active Development - Phase 7.6 Complete

---

## Project Mission

**Lexicon is a faithful recreation of GNU Emacs for the modern web.** We implement Emacs's actual architecture (gap buffers, hierarchical keymaps, mode system, command model) using modern technologies (Rust/WASM, ClojureScript, re-frame).

**Core Philosophy:** "When in doubt, do what Emacs does" - We study Emacs source code before implementing features. This is not Emacs-inspired, this IS Emacs for the browser.

---

## Current Phase & Progress

**Completed:**
- ‚úÖ Phases 0-7.6: Core architecture, event system refactoring, hooks, undo, markers, dynamic context
- ‚úÖ Phase 7.5: First-class markers (engine-level in Rust, ClojureScript API)
- ‚úÖ Phase 7.6: Dynamic execution context (Emacs-style dynamic scope)

**Current Phase:** Phase 7.7 - Package System Foundation & SCI Integration
**Next:** Package loading with SCI sandbox, local package loading, trust model

**Reference:** `docs/ROADMAP.md` for detailed phase breakdown

---

## Architecture Principles

### 1. Userspace/Kernel Split (Emacs C Core / Elisp Layer)

**Rust/WASM "Kernel" (Emacs C core analogy):**
- Gap buffer operations
- UTF-8 text handling
- Performance-critical primitives
- Marker management at engine level

**ClojureScript "Userspace" (Emacs Lisp layer analogy):**
- All user-facing commands (even `self-insert-command`)
- Mode definitions, keymap configurations
- UI rendering (Reagent/React)
- Extensibility and package system

**Rule:** Only functions that need speed go in Rust. Everything else in ClojureScript.

### 2. Core vs Package

**Core** (what you get with `emacs -Q`):
- Buffer/window/frame management
- Keymap system, command dispatcher
- Mode system (major/minor)
- Minibuffer, basic editing
- File I/O, kill ring

**Packages** (external, loadable):
- Evil-mode (vim emulation)
- Vertico/Orderless/Consult (completion)
- Syntax highlighting (beyond basic)
- LSP integration
- Themes

**Rule:** If Emacs doesn't have it by default, it's a package.

### 3. Key Technical Decisions

- **Gap buffer** (not piece tree) - simpler, faster for localized edits, aligns with Emacs
- **Hierarchical keymaps** - exact Emacs precedence order
- **One major mode, many minor modes** per buffer
- **Package system** - git-first, SCI sandbox for untrusted code

---

## Engineering Standards

### Testing Requirements

**Test Coverage Expectations:**
- ‚úÖ **Rust code:** Unit tests required for all public functions
- ‚úÖ **E2E tests:** All user-facing features must have E2E tests
- ‚úÖ **Test-first when possible:** Write tests before implementation for new features
- ‚úÖ **No regressions:** All tests must pass before commit

**Running Tests:**
```bash
# During development
bb test:unit:watch        # Continuous ClojureScript tests

# Before commit
cargo test                # Rust unit tests (in packages/lexicon-engine/wasm)
bb test:e2e               # E2E tests (requires app running at :8080)
bb test                   # All tests (unit + E2E + Rust)
```

**Test Requirements:**
- Add tests when implementing new features (Phase 7.7+)
- Add tests when fixing bugs (regression tests)
- E2E tests cover critical user workflows
- Rust unit tests for gap buffer operations

### Code Organization & Hygiene

**File Size Limits:**
- ‚úÖ **Max ~500 lines per namespace** - Split larger files into focused modules
- ‚úÖ **Example:** `events.cljs` refactored from 2,958 lines ‚Üí 7 modules (~400 lines each)

**Namespace Organization:**
```clojure
packages/editor-cljs/src/lexicon/
‚îú‚îÄ‚îÄ core.cljs              # Main entry point
‚îú‚îÄ‚îÄ db.cljs                # App-db schema
‚îú‚îÄ‚îÄ events/                # Event handlers (by domain)
‚îÇ   ‚îú‚îÄ‚îÄ buffer.cljs
‚îÇ   ‚îú‚îÄ‚îÄ command.cljs
‚îÇ   ‚îú‚îÄ‚îÄ edit.cljs
‚îÇ   ‚îú‚îÄ‚îÄ file.cljs
‚îÇ   ‚îú‚îÄ‚îÄ navigation.cljs
‚îÇ   ‚îú‚îÄ‚îÄ window.cljs
‚îÇ   ‚îî‚îÄ‚îÄ wasm.cljs
‚îú‚îÄ‚îÄ subs.cljs              # Subscriptions
‚îú‚îÄ‚îÄ views.cljs             # UI components
‚îú‚îÄ‚îÄ hooks.cljs             # Hook system
‚îú‚îÄ‚îÄ markers.cljs           # Marker abstraction
‚îú‚îÄ‚îÄ context.cljs           # Dynamic execution context
‚îî‚îÄ‚îÄ advanced_undo.cljs     # Undo system
```

**Rules:**
- Group related functions in same namespace
- Separate concerns (events, subs, views, business logic)
- Use descriptive namespace names
- Refactor when file exceeds ~500 lines

**Code Complexity:**
- Favor small, focused functions over large ones
- Extract helper functions to reduce nesting
- Use meaningful variable names
- Add docstrings to public APIs

**Code Reusability:**
- Extract common patterns into utility functions
- Avoid copy-paste - refactor duplicated code
- Use ClojureScript idioms (destructuring, threading macros)
- Share utilities across namespaces via dedicated files

### Commit Hygiene

**Commit Frequency:**
- ‚úÖ **Commit after each green test run** - Keep commits small and atomic
- ‚úÖ **Commit after completing each step** in roadmap tasks
- ‚úÖ **Commit format:**
  ```
  type(scope): concise description

  - Detailed bullet points
  - Explain what and why, not how
  - Reference phase/step if applicable

  ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

  Co-Authored-By: Claude <noreply@anthropic.com>
  ```

**Commit Types:**
- `feat` - New feature
- `fix` - Bug fix
- `refactor` - Code restructuring (no behavior change)
- `test` - Add/modify tests
- `docs` - Documentation only
- `deps` - Dependency updates
- `ci` - CI/CD changes

**Before Every Commit:**
```bash
# 1. Ensure code compiles
npx shadow-cljs compile app    # ClojureScript
cargo build                     # Rust

# 2. Run tests
cargo test                      # Rust tests
bb test:e2e                     # E2E tests (if applicable)

# 3. Check for warnings
# Fix all warnings before committing - zero tolerance for warnings
```

### Babashka Task Conventions

**Task Naming:**
- Use kebab-case for task names
- Prefix composite tasks with `:` (e.g., `test:unit`, `test:e2e`)
- Add emoji to print-step messages for visual clarity

**Task Documentation:**
- All tasks must have `:doc` string
- Use `print-step` for progress indication:
  ```clojure
  (print-step "üöÄ" "Starting build...")
  (print-step "‚úÖ" "Build complete!")
  (print-step "‚ùå" "Build failed!")
  ```

**Common Tasks:**
```bash
bb dev              # Start development server
bb build            # Full production build
bb test             # Run all tests
bb clean            # Clean build artifacts
bb ci-test          # Simulate CI locally
```

---

## Development Workflow

### Daily Development

```bash
# 1. Start development server
bb dev              # Frontend at http://localhost:8080

# 2. Make changes, verify live reload works

# 3. Before commit:
cargo test          # Rust tests
npx shadow-cljs compile app  # Ensure no warnings
bb test:e2e         # E2E tests (if applicable)

# 4. Commit with descriptive message
git add -A
git commit -m "feat(markers): add overlay marker support"
```

### Debugging Workflow

**Using git diff for Regressions:**
```bash
# Find what changed to cause regression
git diff HEAD~5    # Check last 5 commits
git diff <hash>    # Specific commit

# Bisect to find breaking commit
git bisect start
git bisect bad                    # Current state is bad
git bisect good <known-good>      # Last known good commit
# Git will checkout commits - test each with `bb test`
git bisect good/bad  # Mark each commit
git bisect reset     # When done

# View file-specific changes
git log -p -- path/to/file.cljs
git blame path/to/file.cljs  # Line-by-line attribution
```

**Using Browser DevTools:**
- Check ClojureScript console for errors
- Use re-frame-10x for state inspection (if enabled)
- Network tab for WASM loading issues

**Using Rust Debugging:**
```bash
# Run Rust tests with output
cargo test -- --nocapture

# Run specific test
cargo test test_marker_creation -- --nocapture
```

---

## Security Considerations

### Package Trust Model (Phase 7.7+)

**Trust Levels:**
- **:core** - Built-in packages, full access, native eval
- **:local** - User-installed from filesystem, full access, native eval
- **:external** - Third-party from internet, **SCI sandbox only**, Core API only

**Rules:**
- External packages CANNOT access editor internals
- External packages CANNOT use arbitrary `js/*` access
- External packages can ONLY use Core API functions
- Package load failures must NOT crash editor

### General Security

- Validate all user input (file paths, URLs)
- Sanitize data before rendering (prevent XSS)
- No `eval` on untrusted code (use SCI for external packages)
- Clear error messages without leaking internals

---

## Performance Standards

### Expectations

- ‚úÖ **Editor startup:** < 2 seconds
- ‚úÖ **Command execution:** < 16ms (60 FPS)
- ‚úÖ **File loading:** < 1 second for 10k line files
- ‚úÖ **Package loading:** < 100ms per package (warn if slower)

### Optimization Guidelines

- Profile before optimizing (use browser profiler)
- Gap buffer operations in Rust for speed
- Minimize re-renders (use React.memo, memoize subscriptions)
- Lazy load packages when possible
- Use web workers for heavy computation (future)

### Monitoring

- Log package initialization time (Phase 7.7+)
- Warn if package load > 100ms
- Track command execution time in development

---

## Logging Standards

### When to Log

**Console Logs (Development):**
```clojure
(js/console.log "üé® Updating stylesheet:" id)
(js/console.warn "‚ö†Ô∏è Package load slow:" package-name time-ms)
(js/console.error "‚ùå Hook failed:" hook-id error)
```

**Echo Area (User-Facing):**
```clojure
[:dispatch [:echo/message "Loaded package: vertico"]]
[:dispatch [:show-error "Failed to load package"]]
```

**Structured Logging (Phase 12+):**
- Package lifecycle events (load, unload, enable, disable)
- Package evaluation events (success, failure)
- Performance warnings (slow operations)

### Log Levels

- **Info:** Normal operations (package loaded, command executed)
- **Warn:** Non-critical issues (slow package, deprecated API)
- **Error:** Failures that don't crash (package load failed, hook error)

---

## Key Files & Documentation

**Must Read:**
- `docs/ROADMAP.md` - Phased development plan (THE source of truth)
- `docs/CORE_PRINCIPLES.md` - Architectural philosophy
- `README.md` - Project overview

**Architecture:**
- `docs/architecture.md` - Technical architecture details
- `docs/core/*.md` - Core API contracts (Phase 7+)

**Development:**
- `bb.edn` - Build tasks and tooling
- `packages/editor-cljs/shadow-cljs.edn` - ClojureScript build config
- `packages/lexicon-engine/wasm/Cargo.toml` - Rust dependencies

---

## Common Patterns

### Re-frame Event Pattern

```clojure
(rf/reg-event-fx
  :namespace/action
  (fn [{:keys [db]} [_ arg1 arg2]]
    {:db (update-in db [:path :to :data] f)
     :fx [[:dispatch [:other-event arg1]]
          [:dom/focus-editor]]}))
```

### Re-frame Subscription Pattern

```clojure
(rf/reg-sub
  :namespace/data
  (fn [db [_ id]]
    (get-in db [:path :to :data id])))
```

### Adding New Command

```clojure
;; 1. Define event handler
(rf/reg-event-fx
  :my-command
  (fn [{:keys [db]} [_]]
    {:db (assoc-in db [:some :state] value)}))

;; 2. Register command
(rf/dispatch [:register-command :my-command
              {:docstring "Description"
               :handler [:my-command]}])

;; 3. Bind to keymap
(rf/dispatch [:define-key :global "C-c m" :my-command])

;; 4. Add E2E test
(deftest test-my-command
  (is (= expected-result (execute-command :my-command))))
```

---

## Troubleshooting

### Build Issues

**WASM fails to compile:**
```bash
cd packages/lexicon-engine/wasm
cargo clean
cargo build
wasm-pack build --target web
```

**ClojureScript fails to compile:**
```bash
cd packages/editor-cljs
rm -rf .shadow-cljs
rm -rf resources/public/js
npx shadow-cljs compile app
```

### Test Issues

**E2E tests fail:**
1. Ensure app is running at http://localhost:8080 (`bb dev`)
2. Ensure Firefox is installed
3. Check test logs for specific failures

**Rust tests fail:**
```bash
cd packages/lexicon-engine/wasm
cargo test -- --nocapture
# Look for specific assertion failures
```

### Git Issues

**Merge conflicts:**
```bash
# View conflicts
git status

# Resolve manually, then:
git add <resolved-files>
git commit
```

**Revert bad commit:**
```bash
git revert <commit-hash>  # Creates new commit that undoes changes
# OR
git reset --hard <good-commit>  # DANGEROUS: loses history
```

---

## Quick Reference

### Key Commands

```bash
# Development
bb dev                   # Start dev server
bb test                  # Run all tests
bb clean                 # Clean build artifacts

# Testing
cargo test               # Rust unit tests
bb test:e2e              # E2E tests
bb test:unit:watch       # Watch mode for unit tests

# Building
bb build                 # Production build
bb build-dev             # Development build
bb build-wasm            # Just WASM
bb build-cljs            # Just ClojureScript

# Debugging
git diff HEAD~3          # View recent changes
git log -p -- <file>     # File history with diffs
git bisect               # Find breaking commit
```

### Important Paths

```
packages/editor-cljs/src/lexicon/     # ClojureScript source
packages/lexicon-engine/core/         # Rust gap buffer
packages/lexicon-engine/wasm/         # WASM bindings
e2e_tests/                            # E2E tests
docs/                                 # Documentation
```

---

## Remember

1. ‚úÖ **Test first** - Write tests, then implement
2. ‚úÖ **Commit frequently** - After each green test run
3. ‚úÖ **No warnings** - Fix all warnings before commit
4. ‚úÖ **Small functions** - Refactor when file > 500 lines
5. ‚úÖ **Emacs fidelity** - When in doubt, check Emacs source
6. ‚úÖ **Document as you go** - Update ROADMAP.md when completing phases
7. ‚úÖ **Zero regressions** - All tests must pass
8. ‚úÖ **Git for debugging** - Use `git diff` and `git bisect` to find regressions

---

**This file survives conversation compactions. Keep it updated with new patterns and decisions.**
